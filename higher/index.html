<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="higher"><meta name="keywords" content="rust, rustlang, rust-lang, higher"><title>higher - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-93196c7a1c3542a8.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-4743e13df3dfe8c4.css"><link rel="stylesheet" disabled href="../static.files/dark-0e1b889528bd466b.css"><link rel="stylesheet" disabled href="../static.files/ayu-65289d5d067c7c66.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-3367e395607fafc1.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../higher/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../higher/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate higher</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.2.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#derives">Derive Macros</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">higher</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/higher/lib.rs.html#1-389">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="higher"><a href="#higher">higher</a></h2>
<p>The functor hierarchy and other terrible ideas for Rust.</p>
<p>Yes, this gives you generalisable monads in Rust. No, they’re not very nice compared to Haskell,
because Rust’s functions aren’t quite as first class from the type system’s perspective as you might
like them to be, type constraints in trait implementations can be a serious headache when you want
to implement, say, <code>Functor</code> for <code>HashSet</code>, and the type system can be particularly obtuse at times
and need a lot of additional and extremely verbose guidance to get the type inference right, but
they exist now.</p>
<p>What you get from this:</p>
<ul>
<li>A set of fine grained traits (<code>Functor</code>, <code>Pure</code>, <code>Apply</code>, <code>Bind</code>, <code>Applicative</code> and <code>Monad</code>) for
functors, applicatives and monads, inspired by
<a href="https://pursuit.purescript.org/packages/purescript-prelude">PureScript</a> and Scala’s
<a href="https://typelevel.org/cats/">Cats</a>.</li>
<li>Bifunctors, contravariant functors and profunctors, for completeness.</li>
<li>The <code>run!</code> macro for Haskell style do notation. I’d have preferred to call it <code>do!</code> or <code>for!</code>
but unfortunately those are reserved keywords, even for macros.</li>
<li>Derive macros for <code>Functor</code> and <code>Bifunctor</code>.</li>
<li>Semigroups and monoids, because Rust’s <code>Add</code> isn’t quite a semigroup so <code>Add + Default</code> isn’t
quite a monoid.</li>
<li>Effect monads that wrap standard <code>Future</code>s and IO monads that wrap futures that can fail.</li>
<li>Most of <code>Foldable</code>, with the ambition of some of <code>Traversable</code> to follow. (It’s always
<code>traverse</code>.)</li>
<li>Rings and algebras, just in case.</li>
<li>Not necessarily a lot of good documentation, but like any good Haskell programmer you should be
able to immediately infer every function’s purpose from its type signature.</li>
</ul>
<h3 id="what-are-your-intentions-with-this"><a href="#what-are-your-intentions-with-this">What are your intentions with this?</a></h3>
<p>I wrote this for two reasons: first, to see if it was even possible, and second, as a shitpost with
some extremely elaborate type signatures. If you think this is actually useful (and I’m mildly
horrified to find that I’m starting to think it might be), you may wish to step up to help maintain
it, because I doubt I’ll keep giving it much attention once the novelty wears off.</p>
<h3 id="is-rust-actually-capable-of-this"><a href="#is-rust-actually-capable-of-this">Is Rust actually capable of this?</a></h3>
<p>To everyone’s surprise, with
<a href="https://blog.rust-lang.org/2022/10/28/gats-stabilization.html">generic associated types</a> we can now
express a subset of what higher kinded types give us in Rust. This subset turns out to be sufficient
to implement the abstractions found in the functor hierarchy, but the language still has its
limitations which have a significant impact on the usefulness of these abstractions.</p>
<h4 id="no-constraint-kinds"><a href="#no-constraint-kinds">No constraint kinds</a></h4>
<p>The first is the absence of constraint kinds. In Rust, when implementing a trait, we’re unable to
require stricter constraint bounds in our implementations than the trait itself specifies. While
this has implications outside of GATs too, we run into it very quickly when trying to implement the
most basic part of the functor hierarchy: <code>Functor</code> itself.</p>
<p>We can express <code>Functor</code> as simply as possible like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">trait </span>Functor&lt;A&gt; {
    <span class="kw">type </span>Target&lt;T&gt;;
    <span class="kw">fn </span>fmap&lt;B, F: Fn(A) -&gt; B&gt;(<span class="self">self</span>, f: F) -&gt; <span class="self">Self</span>::Target&lt;B&gt;;
}</code></pre></div>
<p>We can also implement it for the most basic types, such as <code>Vec</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl</span>&lt;A&gt; Functor&lt;A&gt; <span class="kw">for </span>Vec&lt;A&gt; {
    <span class="kw">type </span>Target&lt;T&gt; = Vec&lt;T&gt;;
    <span class="kw">fn </span>fmap&lt;B, F: Fn(A) -&gt; B&gt;(<span class="self">self</span>, f: F) -&gt; <span class="self">Self</span>::Target&lt;B&gt; {
        <span class="self">self</span>.into_iter().map(f).collect()
    }
}</code></pre></div>
<p>But we immediately run into a problem when trying to implement it for a type with constraints on its
type arguments, like <code>HashSet</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl</span>&lt;A: Hash + Eq&gt; Functor&lt;A&gt; <span class="kw">for </span>HashSet&lt;A&gt; {
    <span class="kw">type </span>Target&lt;T&gt; = HashSet&lt;T&gt;;
    <span class="kw">fn </span>fmap&lt;B: Hash + Eq, F: Fn(A) -&gt; B&gt;(<span class="self">self</span>, f: F) -&gt; <span class="self">Self</span>::Target&lt;B&gt; {
        <span class="self">self</span>.into_iter().map(f).collect()
    }
}</code></pre></div>
<p>Here, rustc will complain that the bounds on <code>B</code> are stricter than they are in the trait and refuse
to proceed, but we do need those bounds to be able to implement <code>fmap</code> for <code>HashSet</code>. There’s no
trick available to us, even if we venture into nightly rustc’s feature flags, to allow us to express
this properly, so we’re left entirely unable to implement <code>Functor</code> for <code>HashSet</code>, or for anything
requiring bounds on <code>A</code>, as we have no way to express that they should carry over to the target
type.</p>
<p>There’s an <a href="https://github.com/rust-lang/rfcs/issues/2190">open issue</a> to address this situation
which has been going since 2017 without as much as a concrete proposal, so I don’t think one should
allow oneself to feel too hopeful about a quick resolution to this problem.</p>
<h4 id="gats-arent-higher-kinded-types-and-using-them-as-such-gets-messy"><a href="#gats-arent-higher-kinded-types-and-using-them-as-such-gets-messy">GATs aren’t higher kinded types and using them as such gets messy</a></h4>
<p>We all knew GATs wouldn’t be quite as flexible as higher kinded types, but in some specific ways
they can be <em>more</em> flexible, and not necessarily in a good way for our purposes. Let’s illustrate
with an implementation of <code>Bind</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">trait </span>Bind&lt;A&gt; {
    <span class="kw">type </span>Target&lt;T&gt;;
    <span class="kw">fn </span>then&lt;B, F: Fn(A) -&gt; <span class="self">Self</span>::Target&lt;B&gt;&gt;(<span class="self">self</span>, f: F) -&gt; <span class="self">Self</span>::Target&lt;B&gt;;
}</code></pre></div>
<p>If we’d like to write a function that composes two <code>Bind</code>s into a third, we’d expect it to look like
this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>compose_binds&lt;A, B, C, M, F1, F2&gt;(ma: M, f1: F1, f2: F2) -&gt; M::Target&lt;C&gt;
<span class="kw">where
    </span>M: Bind&lt;A&gt;,
    F1: Fn(A) -&gt; M::Target&lt;B&gt;,
    F2: Fn(B) -&gt; M::Target&lt;C&gt;,
{
    ma.then(|a| f1(a).then(|b| f2(b)))
}</code></pre></div>
<p>However, we have no guarantee that <code>M::Target&lt;B&gt;</code> actually resolves to anything that even implements
<code>Bind</code> in turn, even though we mean the <code>type Target&lt;T&gt;</code> in the trait to always refer back to the
original type constructor. This is just a convention on our part, a GAT in an of itself isn’t
required to follow any such convention. We need to add trait bounds to clarify this in both cases:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>compose_binds&lt;A, B, C, M, F1, F2&gt;(ma: M, f1: F1, f2: F2) -&gt; M::Target&lt;C&gt;
<span class="kw">where
    </span>M: Bind&lt;A&gt;,
    M::Target&lt;B&gt;: Bind&lt;B&gt;,
    M::Target&lt;C&gt;: Bind&lt;C&gt;,
    F1: Fn(A) -&gt; M::Target&lt;B&gt;,
    F2: Fn(B) -&gt; M::Target&lt;C&gt;,
{
    ma.then(|a| f1(a).then(|b| f2(b)))
}</code></pre></div>
<p>This is fair, and expected. However, we’re not done yet, and this is where it gets hairy. We also
can’t be sure that <code>&lt;M::Target&lt;B&gt; as Thenable&lt;B&gt;&gt;::Target&lt;C&gt;</code> will resolve to the same type as
<code>M::Target&lt;C&gt;</code>, so we have to modify our constraints to clarify that this should also be the case:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>compose_binds&lt;A, B, C, M, F1, F2&gt;(ma: M, f1: F1, f2: F2) -&gt; M::Target&lt;C&gt;
<span class="kw">where
    </span>M: Bind&lt;A&gt;,
    M::Target&lt;B&gt;: Bind&lt;B, Target&lt;C&gt; = M::Target&lt;C&gt;&gt;,
    M::Target&lt;C&gt;: Bind&lt;C&gt;,
    F1: Fn(A) -&gt; M::Target&lt;B&gt;,
    F2: Fn(B) -&gt; M::Target&lt;C&gt;,
{
    ma.then(|a| f1(a).then(|b| f2(b)))
}</code></pre></div>
<p>In the above, one might think we could clarify it by specifying
<code>&lt;M::Target&lt;B&gt; as Thenable&lt;B&gt;&gt;::Target&lt;C&gt;</code> instead of <code>M::Target&lt;C&gt;</code> throughout, but this leads
nowhere better, as it turns out.</p>
<p>Finally, the type checker at this point fails to infer that the result type of the second bind call
should be <code>C</code>, so we need to explicitly provide it.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>compose_binds&lt;A, B, C, M, F1, F2&gt;(ma: M, f1: F1, f2: F2) -&gt; M::Target&lt;C&gt;
<span class="kw">where
    </span>M: Bind&lt;A&gt;,
    M::Target&lt;B&gt;: Bind&lt;B, Target&lt;C&gt; = M::Target&lt;C&gt;&gt;,
    M::Target&lt;C&gt;: Bind&lt;C&gt;,
    F1: Fn(A) -&gt; M::Target&lt;B&gt;,
    F2: Fn(B) -&gt; M::Target&lt;C&gt;,
{
    ma.then(|a| f1(a).then::&lt;C, <span class="kw">_</span>&gt;(|b| f2(b)))
}</code></pre></div>
<p>This happens quite frequently, and is the reason the <code>run!</code> macro includes syntax for specifying the
type of a binding. Correct me if I’m wrong, but this part I can’t excuse the type checker for, it
should have been able to figure this out for itself based on the function’s return type.</p>
<p>In conclusion, GATs require considerably more effort to express everyday HTKs than you’d expect from
a language with HKTs, even though you <em>can</em> express these things. This isn’t a shortcoming of GATs
(in fact, it’s a feature that HKTs don’t provide), but it’s a real problem when you’re trying to
express abstractions like these which on the surface should have been much simpler. There’s also the
added problem that the more you compensate for this behaviour, the more your implementation details
leak out into the type signature in ways they really shouldn’t. This is especially unfortunate when
you’re dealing with traits, where you’ll need to predict ahead of time all the ways in which your
implementers will need this kind of extra support in the type signatures.</p>
<h4 id="conclusion"><a href="#conclusion">Conclusion</a></h4>
<p>So, is Rust ready for the functor hierarchy? We’re frustratingly close, but I think in the end the
answer is no.</p>
<p>Basic abstractions like <code>Functor</code> would work well if we had constraint kinds, but as soon as you
step outside the basic use casees, you begin to see where GATs aren’t an adequate substitute for
higher kinded types. That is to say, they solve a <em>different</em> problem from HKTs, and it’s not
straightforward to attempt to use them as a substitute. There are improvements which could be made
to Rust’s type checker which could alleviate some, but not all or even most of these issues.</p>
<p>This entire crate should therefore be considered as an exercise, and perhaps as a guide towards new
language features, more than as a practical implementation. I do really see a genuine need for
constraint kinds in Rust beyond this crate. I also suspect Rust would have been better off with
actual higher kinded types, but that’s a lost cause at this point.</p>
<p>Interestingly, though, while I was expecting Rust’s borrow checker and the fact that it
differentiates so clearly between owned values and mutable and immutable references to be a primary
barrier to the implementation of this crate, this turned out to be more of an issue of API design
than anything else. The primary problem here was the inability to refine <code>Clone</code> requirements where
needed because of the absence of constraint kinds.</p>
<p>It’s also unfortunate that I couldn’t implement <code>Apply</code> for anything but boxed functions (as bare
functions with the same type signature on the surface aren’t consistently typed in Rust, nor can
they be <code>Sized</code>), making it decidedly less than a zero cost abstraction, but I consider this a minor
issue even if it should make one cautious when describing Rust as a functional programming language
(which I don’t think one should).</p>
<h3 id="licence"><a href="#licence">Licence</a></h3>
<p>Copyright 2019 Bodil Stokke</p>
<p>This software is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL
was not distributed with this file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>.</p>
<h3 id="code-of-conduct"><a href="#code-of-conduct">Code of Conduct</a></h3>
<p>Please note that this project is released with a <a href="https://github.com/bodil/higher/blob/master/CODE_OF_CONDUCT.md">Contributor Code of Conduct</a>. By
participating in this project you agree to abide by its terms.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="algebras/index.html" title="higher::algebras mod">algebras</a></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="alt/index.html" title="higher::alt mod">alt</a></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="alternative/index.html" title="higher::alternative mod">alternative</a></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="applicative/index.html" title="higher::applicative mod">applicative</a></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="apply/index.html" title="higher::apply mod">apply</a></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="bifunctor/index.html" title="higher::bifunctor mod">bifunctor</a></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="bind/index.html" title="higher::bind mod">bind</a></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="contra/index.html" title="higher::contra mod">contra</a></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="error/index.html" title="higher::error mod">error</a></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="foldable/index.html" title="higher::foldable mod">foldable</a></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="functor/index.html" title="higher::functor mod">functor</a></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="monad/index.html" title="higher::monad mod">monad</a></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="monadplus/index.html" title="higher::monadplus mod">monadplus</a></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="monoid/index.html" title="higher::monoid mod">monoid</a></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="plus/index.html" title="higher::plus mod">plus</a></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="profunctor/index.html" title="higher::profunctor mod">profunctor</a></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="pure/index.html" title="higher::pure mod">pure</a></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="rings/index.html" title="higher::rings mod">rings</a></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="semigroup/index.html" title="higher::semigroup mod">semigroup</a></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="traversable/index.html" title="higher::traversable mod">traversable</a></div></div></div><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.run.html" title="higher::run macro">run</a></div><div class="item-right docblock-short">Monadic do notation.</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Alt.html" title="higher::Alt trait">Alt</a></div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Alternative.html" title="higher::Alternative trait">Alternative</a></div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Applicative.html" title="higher::Applicative trait">Applicative</a></div><div class="item-right docblock-short">An <code>Applicative</code> functor is anything which implements <a href="trait.Functor.html"><code>Functor</code></a>,
<a href="trait.Apply.html"><code>Apply</code></a> and <a href="trait.Pure.html"><code>Pure</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.ApplicativeError.html" title="higher::ApplicativeError trait">ApplicativeError</a></div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Apply.html" title="higher::Apply trait">Apply</a></div><div class="item-right docblock-short"><code>Apply</code> takes an <code>Apply&lt;Fn(A) -&gt; B&gt;</code> (or, rather, an <code>Apply&lt;ApplyFn&lt;'a, A, B&gt;&gt;</code> specifically) and applies it to an <code>Apply&lt;A&gt;</code> to produce an <code>Apply&lt;B&gt;</code>.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Bifunctor.html" title="higher::Bifunctor trait">Bifunctor</a></div><div class="item-right docblock-short">A <code>Bifunctor</code> lets you change the types of a generic type with two type
parameters.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.BifunctorRef.html" title="higher::BifunctorRef trait">BifunctorRef</a></div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Bind.html" title="higher::Bind trait">Bind</a></div><div class="item-right docblock-short"><code>Bind</code> lets you chain computations together.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Contravariant.html" title="higher::Contravariant trait">Contravariant</a></div><div class="item-right docblock-short">A <code>Contravariant</code> functor.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Foldable.html" title="higher::Foldable trait">Foldable</a></div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Functor.html" title="higher::Functor trait">Functor</a></div><div class="item-right docblock-short">A <code>Functor</code> lets you change the type parameter of a generic type.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.FunctorRef.html" title="higher::FunctorRef trait">FunctorRef</a></div><div class="item-right docblock-short"><code>FunctorRef</code> is an extension to <a href="trait.Functor.html"><code>Functor</code></a> which provides a
non-destructive <a href="trait.Functor.html#tymethod.fmap"><code>fmap</code></a> passing references to the mapping
function.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Monad.html" title="higher::Monad trait">Monad</a></div><div class="item-right docblock-short">A <code>Monad</code> is like a burrito, and also anything which implements
<a href="trait.Bind.html"><code>Bind</code></a> and <a href="trait.Applicative.html"><code>Applicative</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.MonadError.html" title="higher::MonadError trait">MonadError</a></div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.MonadPlus.html" title="higher::MonadPlus trait">MonadPlus</a></div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Monoid.html" title="higher::Monoid trait">Monoid</a></div><div class="item-right docblock-short">A <code>Monoid</code> consists of a <a href="trait.Semigroup.html"><code>Semigroup</code></a> and an empty value (the
<a href="https://doc.rust-lang.org/1.68.2/core/default/trait.Default.html"><code>Default</code></a> trait) plus the following laws:</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Plus.html" title="higher::Plus trait">Plus</a></div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Profunctor.html" title="higher::Profunctor trait">Profunctor</a></div><div class="item-right docblock-short">A <code>Profunctor</code> is just a <code>Bifunctor</code> that is contravariant over its first
argument and covariant over its second argument. What’s the problem?</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Pure.html" title="higher::Pure trait">Pure</a></div><div class="item-right docblock-short"><code>Pure</code> lets you construct a value of type <code>F&lt;A&gt;</code> from a single value of <code>A</code>.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Semigroup.html" title="higher::Semigroup trait">Semigroup</a></div><div class="item-right docblock-short">A <code>Semigroup</code> is a type with an associative operation. In plain terms, this
means you can take two values of this type and add them together into a
different value of the same type. The most obvious example of this is
addition of numbers: <code>2 + 2 = 4</code>, another is string concatenation:
<code>&quot;Hello &quot; + &quot;Joe&quot; = &quot;Hello Joe&quot;</code>.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Traversable.html" title="higher::Traversable trait">Traversable</a></div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.repeat.html" title="higher::repeat fn">repeat</a></div><div class="item-right docblock-short">Construct a function that ignores its argument and returns the same value
every time you call it.</div></div></div><h2 id="derives" class="small-section-header"><a href="#derives">Derive Macros</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="derive" href="derive.Bifunctor.html" title="higher::Bifunctor derive">Bifunctor</a></div></div><div class="item-row"><div class="item-left module-item"><a class="derive" href="derive.BifunctorRef.html" title="higher::BifunctorRef derive">BifunctorRef</a></div></div><div class="item-row"><div class="item-left module-item"><a class="derive" href="derive.Functor.html" title="higher::Functor derive">Functor</a></div></div><div class="item-row"><div class="item-left module-item"><a class="derive" href="derive.FunctorRef.html" title="higher::FunctorRef derive">FunctorRef</a></div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="higher" data-themes="" data-resource-suffix="" data-rustdoc-version="1.68.2 (9eb3afe9e 2023-03-27)" data-search-js="search-98d53477a794af0b.js" data-settings-js="settings-c3c521c753752a1a.js" data-settings-css="settings-08ddfdda51b8ee2e.css" ></div></body></html>